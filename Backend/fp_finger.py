# -*- coding: utf-8 -*-
"""fp_finger.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UWttKUDAYcCuutNw9X8Do_L06rprXy5b
"""

import tensorflow as tf
tf.test.gpu_device_name()

import zipfile

!unzip /content/drive/MyDrive/archive.zip

import numpy as np
import cv2
import os
import pandas as pd
import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import keras

from tensorflow.keras import Sequential
from tensorflow.keras.layers import Conv2D, MaxPool2D, Dense,Dropout, Flatten
from tensorflow.keras import layers
from tensorflow.keras import optimizers

from keras.preprocessing.image import ImageDataGenerator
from keras.callbacks import ReduceLROnPlateau
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import seaborn as sns

def extract_label(img_path, train=True):
    filename, _ = os.path.splitext(os.path.basename(img_path))
    subject_id, etc = filename.split('__')

    if train:
        gender, lr, finger, _, _ = etc.split('_')
    else:
        gender, lr, finger, _ = etc.split('_')

    gender = 0 if gender == 'M' else 1
    lr =0 if lr == 'Left' else 1

    if finger == 'thumb':
        finger = 0
    elif finger == 'index':
        finger = 1
    elif finger == 'middle':
        finger = 2
    elif finger == 'ring':
        finger = 3
    elif finger == 'little':
        finger = 4

    return np.array([finger], dtype=np.uint16)

def load_data(path, train):
    print("loading data from: ", path)
    data = []
    for img in os.listdir(path):
            img_array = cv2.imread(os.path.join(path, img), cv2.IMREAD_GRAYSCALE)
            img_resize = cv2.resize(img_array, (96, 96))
            label = extract_label(os.path.join(path, img),train)
            data.append([label[0], img_resize ])

    return data

Hard_path='/content/SOCOFing/Altered/Altered-Hard'
Easy_path='/content/SOCOFing/Altered/Altered-Easy'
Medium_path='/content/SOCOFing/Altered/Altered-Medium'
Real_path='/content/SOCOFing/Real'

Easy_data = load_data(Easy_path, train = True)
Medium_data = load_data(Medium_path, train = True)
Hard_data = load_data(Hard_path, train = True)
test = load_data(Real_path, train = False)

img, labels = [], []
for label, feature in Easy_data:
    labels.append(label)
    img.append(feature)

for label, feature in Medium_data:
    labels.append(label)
    img.append(feature)

for label, feature in Hard_data:
    labels.append(label)
    img.append(feature)

X_train  = np.array(img).reshape(-1, 96, 96, 1)
X_train  = X_train  / 255.0

print(X_train .ndim)
print(X_train .shape)

y_train = np.array(labels)

X_train.shape, y_train.shape

np.unique(y_train)

model = Sequential()
model.add(Conv2D(filters=64, kernel_size=(5,5), padding='same', activation='relu', input_shape=(96, 96, 1)))
model.add(MaxPool2D(strides=2))
model.add(Conv2D(filters=64, kernel_size=(5,5), padding='valid', activation='relu'))
model.add(MaxPool2D(strides=2))
model.add(Flatten())
model.add(Dense(256, activation='relu'))
model.add(Dense(128, activation='relu'))
model.add(Dense(5, activation='softmax'))

model.summary()

model.compile(optimizer = optimizers.Adam(learning_rate=0.0001),loss='sparse_categorical_crossentropy',metrics=['accuracy'])

history = model.fit(X_train,y_train, batch_size=128, epochs=30, validation_split=0.2)

plt.figure(0)
plt.plot(history.history['accuracy'], label='training accuracy')
plt.plot(history.history['val_accuracy'], label='val accuracy')
plt.title("Accuracy")
plt.xlabel('epochs')
plt.ylabel('accuracy')
plt.legend()
plt.show()
plt.figure(1)
plt.plot(history.history['loss'], label='training loss')
plt.plot(history.history['val_loss'], label='val loss')
plt.title('Loss')
plt.xlabel('epochs')
plt.ylabel('loss')
plt.legend()
plt.show()

X_test,y_test = [],[]

for label, feature in test:
    y_test.append(label)
    X_test.append(feature)

X_test = np.array(X_test).reshape(-1,96,96,1)
X_test = X_test/255

y_test = np.array(y_test)

model.evaluate(X_test,y_test)

predictions = model.predict(X_test)
predictions[:5]

predicted = [np.argmax(i) for i in predictions]
predicted[:5]

import tensorflow as tf
cm = tf.math.confusion_matrix(labels=y_test,predictions=predicted)

import seaborn as sn

sn.heatmap(cm,annot=True,fmt='d',cmap="YlGnBu")
plt.xlabel("Predictions")
plt.ylabel("Truth")

model.save('GenderFP_finger.keras')

for i in range(20):
    print('True: ',y_test[i])
    print('predicted: ',model.predict(np.expand_dims(X_test[i],0))[0])
    print()
    plt.imshow(X_test[i],'gray')
    plt.show()

from sklearn.metrics import precision_score, recall_score, f1_score

import joblib

joblib.dump(model, 'fp_model_finger.joblib')

print(y_test.dtype)
print(y_test.ndim)
print(y_test.shape)

predicted=np.array(predicted)
print(predicted.dtype)
print(predicted.ndim)
print(predicted.shape)

precision = precision_score(y_test, predicted,average=None)
recall = recall_score(y_test, predicted,average=None)
f1score = f1_score(y_test,predicted,average=None)

print("Calculated scores for each class")
print("Precision:", precision)
print("Recall:", recall)
print("F1 Score:", f1score)

precision = precision_score(y_test, predicted, average='micro')
recall = recall_score(y_test, predicted, average='micro')
f1 = f1_score(y_test, predicted, average='micro')

print("Calculated micro-averaged scores ")
print("Micro-averaged Precision:", precision)
print("Micro-averaged Recall:", recall)
print("Micro-averaged F1-score:", f1)

precision = precision_score(y_test, predicted, average='macro')
recall = recall_score(y_test, predicted, average='macro')
f1 = f1_score(y_test, predicted, average='macro')

print("Calculated macro-averaged scores ")
print("Macro-averaged Precision:", precision)
print("Macro-averaged Recall:", recall)
print("Macro-averaged F1-score:", f1)

precision = precision_score(y_test, predicted, average='weighted')
recall = recall_score(y_test, predicted, average='weighted')
f1 = f1_score(y_test, predicted, average='weighted')

print("Calculated weighted-averaged scores ")
print("weighted Precision:", precision)
print("weighted Recall:", recall)
print("weighted F1-score:", f1)